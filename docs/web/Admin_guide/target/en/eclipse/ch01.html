<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;1.&nbsp;Components of the Katzenpost mixnet</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Katzenpost Administrator's Guide"><link rel="up" href="index.html" title="Katzenpost Administrator's Guide"><link rel="prev" href="index.html" title="Katzenpost Administrator's Guide"><link rel="next" href="ch01s02.html" title="Mix, gateway, and service nodes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="components"></a>Chapter&nbsp;1.&nbsp;Components of the Katzenpost mixnet</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="ch01.html#auth">Directory authorities</a></span></dt><dt><span class="section"><a href="ch01s02.html">Mix, gateway, and service nodes</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="auth"></a>Directory authorities</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="auth-config"></a>Configuring directory authorities</h3></div></div></div><p>The following configuration is drawn from the reference implementation in
                <code class="filename">katzenpost/docker/voting_mixnet/auth1/authority.toml</code>. In a
                real-world mixnet, the component hosts would not be sharing a single IP address. For
                more information about the test mixnet, see <a class="link" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Using the Katzenpost test network">Using the Katzenpost test network</a>.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-server-section-config"></a>Server section</h4></div></div></div><p></p><pre class="programlisting">[Server]
    Identifier = "auth1"
    WireKEMScheme = "xwing"
    PKISignatureScheme = "Ed25519"
    Addresses = ["127.0.0.1:30001"]
    DataDir = "/voting_mixnet/auth1"</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Identifier</strong></span></p><p>Identifier is the human readable identifier for the node (eg:
                            FQDN).</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>WireKEMScheme</strong></span></p><p>WireKEMScheme is the wire protocol KEM scheme to use.</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>PKISignatureScheme</strong></span></p><p>PKISignatureScheme specifies the cryptographic signature scheme</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>Addresses</strong></span></p><p>// Addresses are the IP address/port combinations that the server will
                            bind</p><p> // to for incoming connections.</p><p>Type: []string</p></li><li class="listitem"><p><span class="bold"><strong>DataDir</strong></span></p><p>DataDir is the absolute path to the server's state files.</p><p>Type: string</p></li></ul></div><p></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-authorities-section-config"></a>Authorities section</h4></div></div></div><p>An Authorities section is configured for each peer authority.</p><pre class="programlisting">[[Authorities]]
    Identifier = "auth1"
    IdentityPublicKey = "-----BEGIN ED25519 PUBLIC KEY-----\n/v3qYgh2TvV5ZqEVgwcjJHG026KlRV6HC16xZS3TkiI=\n-----END ED25519 PUBLIC KEY-----\n"
    PKISignatureScheme = "Ed25519"
    LinkPublicKey = "-----BEGIN XWING PUBLIC KEY-----\nJeFaZoYQEOO71zPFFWjL7DyDp4gckGiiqLCB2RNwMacZ7wuroYugiXyir+eqvkpe\nw5k3sqm9LlS5xaEqsmJpRxYCOmaHdXARwNA6rOFwEANrZFO&gt;
    WireKEMScheme = "xwing"
    Addresses = ["127.0.0.1:30001"]

[[Authorities]]
    Identifier = "auth2"
    IdentityPublicKey = "-----BEGIN ED25519 PUBLIC KEY-----\n60KQRhG7njt+kLQuwWlfRzJeOp4elM1/k26U/k52SjI=\n-----END ED25519 PUBLIC KEY-----\n"
    PKISignatureScheme = "Ed25519"
    LinkPublicKey = "-----BEGIN XWING PUBLIC KEY-----\nHVR2m7i6G6cf1qxUvyEr3KC7JvAMv5Or1rgzvUcllnmhN8BGmOmWhrWLggBNsyyS\nx+gbkfczC8WZr4GDAXOmGchhEYRy9opjqxEBENW9IHU1Dvh&gt;
    WireKEMScheme = "xwing"
    Addresses = ["127.0.0.1:30002"]

[[Authorities]]
    Identifier = "auth3"
    IdentityPublicKey = "-----BEGIN ED25519 PUBLIC KEY-----\naZUXqznyLO2mKDceIDs0obU6GAFZa3eKUDXo2RyWpBk=\n-----END ED25519 PUBLIC KEY-----\n"
    PKISignatureScheme = "Ed25519"
    LinkPublicKey = "-----BEGIN XWING PUBLIC KEY-----\nEZukXtZwHTjGj7tCI0kmUcq0QEtA4HMIz2OPiXQVeaK9XVBDNQUKq8iGRvzJAodM\nmJiEXYw6vvTJhPaik4OgMpZvwQYNn9BmwrcE7VxQfuaD2Zc&gt;
    WireKEMScheme = "xwing"
    Addresses = ["127.0.0.1:30003"]</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Identifier</strong></span></p><p>Human readable identifier for the node (eg: FQDN)</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>IdentityPublicKey</strong></span></p><p>String in PEM format containing the public identity key key.</p><p>Type: sign.PublicKey</p></li><li class="listitem"><p><span class="bold"><strong>PKISignatureScheme</strong></span></p><p>PKISignatureScheme specifies the cryptographic signature scheme</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>LinkPublicKey</strong></span></p><p>LinkPublicKeyPem is string containing the PEM format of the peer's
                            public link layer key.</p><p>Type: kem.PublicKey</p></li><li class="listitem"><p><span class="bold"><strong>WireKEMScheme</strong></span></p><p>WireKEMScheme is the wire protocol KEM scheme to use.</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>Addresses</strong></span></p><p>One
                            or more IP addresses that correspond to local network interfaces to
                            listen for connections on. These can be specified as IPv4 or IPv6
                            addresses.</p><p>// Addresses are the IP address/port combinations that the peer
                            authority</p><p> // uses for the Directory Authority service.</p><p>Type: []string</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-logging"></a>Logging section</h4></div></div></div><p>The logging configuration section controls logging.</p><pre class="programlisting">[Logging]
    Disable = false
    File = "katzenpost.log"
    Level = "INFO"</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Disable</strong></span></p><p>Disables logging if set to <span class="bold"><strong>true</strong></span>.</p><p>Type: bool</p></li><li class="listitem"><p><span class="bold"><strong>File</strong></span></p><p>Specifies the log file. If omitted, stdout is used.</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>Level</strong></span></p><p>Supported values are ERROR | WARNING | NOTICE |INFO | DEBUG.</p><p>Type: string</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="assets/images/warning.svg"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><p>The DEBUG log level is unsafe for
                production use.</p></td></tr></table></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-parameters"></a>Parameters section</h4></div></div></div><p>The Parameters section holds the network parameters, for example:</p><pre class="programlisting">[Parameters]
    SendRatePerMinute = 0
    Mu = 0.005
    MuMaxDelay = 1000
    LambdaP = 0.001
    LambdaPMaxDelay = 1000
    LambdaL = 0.0005
    LambdaLMaxDelay = 1000
    LambdaD = 0.0005
    LambdaDMaxDelay = 3000
    LambdaM = 0.0005
    LambdaG = 0.0
    LambdaMMaxDelay = 100
    LambdaGMaxDelay = 100</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>SendRatePerMinute</strong></span></p><p>
                            is the rate limiter maximum allowed rate of packets per
                            client.</p><p>SendRatePerMinute is the rate per minute.</p><p>Type: uint64</p></li><li class="listitem"><p><span class="bold"><strong>Mu</strong></span></p><p>
                            is
                            the inverse of the mean of the exponential distribution that the Sphinx
                            packet per-hop mixing delay will be sampled
                            from.</p><p>// Mu is the inverse of the mean of the exponential
                            distribution</p><p> // that is used to select the delay for each hop.</p><p>Type: float64</p></li><li class="listitem"><p><span class="bold"><strong>MuMaxDelay</strong></span></p><p>
                            is the maximum Sphinx packet per-hop mixing delay in
                            milliseconds.</p><p>MuMaxDelay sets the maximum delay for
                            Mu</p><p>Type:
                            uint64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaP</strong></span></p><p>
                            LambdaP is the inverse of the mean of the exponential distribution that
                            clients will sample to determine the time interval between sending
                            messages from it's FIFO egress queue or drop decoy messages if the queue
                            is empty.</p><p>// LambdaP is the inverse of the mean of the exponential
                            distribution</p><p> // that is used to select the delay between clients sending from
                            their egress</p><p> // FIFO queue or drop decoy message.</p><p>Type: float64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaPMaxDelay</strong></span></p><p>
                            is
                            the maximum send interval for LambdaP in
                            milliseconds</p><p>LambdaPMaxDelay sets the maximum delay for LambdaP.</p><p>Type: uint64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaL</strong></span></p><p>LambdaL is the inverse of the mean of the exponential distribution
                            that is used to select the delay between clients sending loop
                            decoys.</p><p>Type: float64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaLMaxDelay</strong></span></p><p>
                            sets the maximum send interval for LambdaL in milliseconds.</p><p>LambdaLMaxDelay sets the maximum delay for
                            LambdaP.</p><p>Type: uint64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaD</strong></span></p><p>
                            is
                            the inverse of the mean of the exponential distribution that clients
                            will sample to determine the time interval between sending decoy drop
                            messages.</p><p>// LambdaD is the inverse of the mean of the exponential
                            distribution</p><p> // that is used to select the delay between clients sending deop
                            decoys.</p><p>Type: float64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaDMaxDelay</strong></span></p><p>
                            is the maximum send interval in milliseconds.</p><p>LambdaDMaxDelay sets the maximum delay for LambdaP.</p><p>Type: uint64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaM</strong></span></p><p>
                            is
                            the inverse of the mean of the exponential distribution that mixes will
                            sample to determine send timing of mix loop decoy
                            traffic.</p><p>// LambdaM is the inverse of the mean of the exponential
                            distribution</p><p> // that is used to select the delay between sending mix node
                            decoys.</p><p>Type: float64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaG</strong></span></p><p>// LambdaG is the inverse of the mean of the exponential
                            distribution</p><p> // that is used to select the delay between sending gateway node
                            decoys.</p><p> //</p><p> // WARNING: This is not used via the TOML config file; this field is
                            only</p><p> // used internally by the dirauth server state machine.</p><p>Type: float64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaMMaxDelay</strong></span></p><p>
                            sets the maximum delay for LambdaM</p><p>LambdaMMaxDelay sets the maximum delay for LambdaP.</p><p>Type: uint64</p></li><li class="listitem"><p><span class="bold"><strong>LambdaGMaxDelay</strong></span></p><p>LambdaGMaxDelay sets the maximum delay for LambdaG.</p><p>Type: uint64</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-debug"></a>Debug section</h4></div></div></div><p></p><pre class="programlisting">[Debug]
    Layers = 3
    MinNodesPerLayer = 1
    GenerateOnly = false</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Layers</strong></span></p><p> Number of
                            non-provider
                            layers in the network topology.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>MinNodesrPerLayer</strong></span></p><p> Minimum number of nodes per layer required to form a valid
                            document.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>GenerateOnly</strong></span></p><p>If set to true, the server halts and cleans up the data directory
                            immediately after long-term key generation.</p><p>Type: bool</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-mixes-section-config"></a>Mixes sections</h4></div></div></div><p>The
                    Mixes configuration section lists mix nodes that are known to the
                    authority.</p><pre class="programlisting">[[Mixes]]
    Identifier = "mix1"
    IdentityPublicKeyPem = "../mix1/identity.public.pem"

[[Mixes]]
    Identifier = "mix2"
    IdentityPublicKeyPem = "../mix2/identity.public.pem"

[[Mixes]]
    Identifier = "mix3"
    IdentityPublicKeyPem = "../mix3/identity.public.pem"</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Identifier</strong></span></p><p>A human readable mix node identifier.</p><p>Type:
                            string</p></li><li class="listitem"><p><span class="bold"><strong>IdentityPublicKeyPem</strong></span></p><p>Path and file name of a mix node's public EdDSA signing key, also
                            known as the identity key, in Base16 or Base64 format.</p><p>Type: string</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-gatewaynodes-section-config"></a>GatewayNodes sections</h4></div></div></div><p>The GatewayNodes configuration section lists gateway nodes that are known to
                    the authority.</p><pre class="programlisting">[[GatewayNodes]]
    Identifier = "gateway1"
    IdentityPublicKeyPem = "../gateway1/identity.public.pem"</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Identifier</strong></span></p><p>A human readable gateway node identifier.</p><p>Type:
                            string</p></li><li class="listitem"><p><span class="bold"><strong>IdentityPublicKeyPem</strong></span></p><p>Path and file name of a gateway node's public EdDSA signing key, also
                            known as the identity key, in Base16 or Base64 format.</p><p>Type: string</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-servicenodes-section-config"></a>ServiceNodes sections</h4></div></div></div><p>The ServiceNodes configuration section lists service nodes that are known to
                    the authority.</p><pre class="programlisting">[[ServiceNodes]]
    Identifier = "servicenode1"
    IdentityPublicKeyPem = "../servicenode1/identity.public.pem"</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Identifier</strong></span></p><p>A human readable service node identifier.</p><p>Type:
                            string</p></li><li class="listitem"><p><span class="bold"><strong>IdentityPublicKeyPem</strong></span></p><p>Path and file name of a service node's public EdDSA signing key, also
                            known as the identity key, in Base16 or Base64 format.</p><p>Type: string</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-topology"></a>Topology section</h4></div></div></div><p>The Topology configuration section defines the layers of the mix network and
                    the mix nodes in each layer.</p><pre class="programlisting">[Topology]
                    
    [[Topology.Layers]]
    
        [[Topology.Layers.Nodes]]
            Identifier = "mix1"
            IdentityPublicKeyPem = "../mix1/identity.public.pem"
    
    [[Topology.Layers]]
    
        [[Topology.Layers.Nodes]]
            Identifier = "mix2"
            IdentityPublicKeyPem = "../mix2/identity.public.pem"
    
    [[Topology.Layers]]
    
        [[Topology.Layers.Nodes]]
            Identifier = "mix3"
            IdentityPublicKeyPem = "../mix3/identity.public.pem"</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>Identifier</strong></span></p><p>A human readable mix node identifier.</p><p>Type:
                            string</p></li><li class="listitem"><p><span class="bold"><strong>IdentityPublicKeyPem</strong></span></p><p>Path and file name of a mix node's public EdDSA signing key, also
                            known as the identity key, in Base16 or Base64 format.</p><p>Type: string</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="auth-sphinx-config"></a>SphinxGeometry section</h4></div></div></div><p></p><pre class="programlisting">[SphinxGeometry]
    PacketLength = 3082
    NrHops = 5
    HeaderLength = 476
    RoutingInfoLength = 410
    PerHopRoutingInfoLength = 82
    SURBLength = 572
    SphinxPlaintextHeaderLength = 2
    PayloadTagLength = 32
    ForwardPayloadLength = 2574
    UserForwardPayloadLength = 2000
    NextNodeHopLength = 65
    SPRPKeyMaterialLength = 64
    NIKEName = "x25519"
    KEMName = ""</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="bold"><strong>PacketLength</strong></span></p><p>PacketLength is the length of a packet.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>NrHops</strong></span></p><p>// NrHops is the number of hops, this indicates the size</p><p> // of the Sphinx packet header.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>HeaderLength</strong></span></p><p> HeaderLength is the length of the Sphinx packet header in
            bytes.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>RoutingInfoLength</strong></span></p><p>RoutingInfoLength is the length of the routing info portion of the
            header.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>PerHopRoutingInfoLength</strong></span></p><p>PerHopRoutingInfoLength is the length of the per hop routing
            info.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>SURBLength</strong></span></p><p>SURBLength is the length of SURB.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>SphinxPlaintextHeaderLength</strong></span></p><p>SphinxPlaintextHeaderLength is the length of the plaintext
            header.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>PayloadTagLength</strong></span></p><p>PayloadTagLength is the length of the payload tag.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>ForwardPayloadLength</strong></span></p><p>ForwardPayloadLength is the size of the payload.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>UserForwardPayloadLength</strong></span></p><p>the size of the usable payload.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>NextNodeHopLength</strong></span></p><p>// NextNodeHopLength is derived off the largest routing info</p><p> // block that we expect to encounter. Everything else just has
            a</p><p> // NextNodeHop + NodeDelay, or a Recipient, both cases which
            are</p><p> // shorter.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>SPRPKeyMaterialLength</strong></span></p><p>SPRPKeyMaterialLength is the length of the SPRP key.</p><p>Type: int</p></li><li class="listitem"><p><span class="bold"><strong>NIKEName</strong></span></p><p>// NIKEName is the name of the NIKE scheme used by the mixnet's Sphinx
            packet.</p><p> // NIKEName and KEMName are mutually exclusive.</p><p>Type: string</p></li><li class="listitem"><p><span class="bold"><strong>KEMName</strong></span></p><p>KEMName is the name of the KEM scheme used by the mixnet's Sphinx
            packet. NIKEName and KEMName are mutually exclusive.</p><p>Type: string</p></li></ul></div></div></div></div></div></body></html>